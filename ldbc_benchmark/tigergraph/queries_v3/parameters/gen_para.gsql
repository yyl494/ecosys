# generate the parameters automatically. The parameters must yield non-empty results.
USE GRAPH ldbc_snb
SET syntax_version = "v2"

CREATE OR REPLACE DISTRIBUTED QUERY gen() {
  SumAccum<UINT> @ncomment;
  SetAccum<UINT> @@personId, @@commentId;
  SetAccum<STRING> @@country, @@tag, @@tagclass, @@firstName;

  V = {Country.*};
  V = SELECT v FROM V:v LIMIT 4;
  V = SELECT v FROM V:v ACCUM @@country += v.name; 
  V = {TagClass.*};
  V = SELECT v FROM V:v LIMIT 3;
  V = SELECT v FROM V:v ACCUM @@tagclass += v.name;
  T = SELECT t FROM Tag:t
    ACCUM t.@ncomment += t.outdegree("HAS_TAG_REVERSE")
    HAVING t.@ncomment > 6000
    ORDER BY t.@ncomment ASC
    LIMIT 10;
  T = SELECT t FROM T:t ACCUM @@tag += t.name;
  P = {Person.*};
  P = SELECT p FROM P:p WHERE p.id > 0 LIMIT 4;
  P = SELECT p FROM P:p  ACCUM @@personId += p.id, @@firstName += p.firstName;
  M = {Comment.*};
  M = SELECT m FROM M:m  WHERE m.id >0 LIMIT 4;
  M = SELECT m FROM M:m  ACCUM @@commentId += m.id;
  PRINT @@country, @@tag, @@tagclass, @@personId, @@commentId, @@firstName;
}
CREATE OR REPLACE DISTRIBUTED QUERY gen_bi10(){
  UINT personId, pid;
  STRING tagClass, country;
  T = SELECT t FROM TagClass:tc-(<HAS_TYPE)-Tag:t LIMIT 1;
  TC = SELECT tc FROM T-(HAS_TYPE>)-TagClass:tc POST-ACCUM tagClass = tc.name;
  M = SELECT m FROM T-(<HAS_TAG)-Comment:m LIMIT 1;
  P = SELECT p FROM M -(HAS_CREATOR>)-Person:p;
  Cn = SELECT cn FROM P -(IS_LOCATED_IN>.IS_PART_OF>)-Country:cn
    POST-ACCUM country = cn.name;
  P1 = SELECT t FROM P-(KNOWS)-Person:t
    WHERE t.id > 0
    LIMIT 3;
  P2 = SELECT t FROM P1-(KNOWS)-Person:t
    WHERE t.id > 0
    LIMIT 3;
  P3 = SELECT t FROM P2-(KNOWS)-Person:t
    WHERE t.id > 0
    LIMIT 3;
  P3 = SELECT t FROM P3:t
    ACCUM personId = t.id;
    
  PRINT personId, country ,tagClass;
}

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi15() {
  OrAccum @flag,@visited;
  UINT person1Id, person2Id, iter; 
  P = {Person.*};
  P = SELECT p FROM P:p-(KNOWS)-Person WHERE p.id > 0 LIMIT 1;
  S = SELECT p FROM P:p ACCUM person1Id = p.id, p.@visited+=true;
  iter = 0;
  WHILE S.size()>0 AND iter < 3 DO
    iter = iter+1;
    Next = SELECT t FROM S-(KNOWS)-Person:t 
      WHERE NOT t.@visited AND t.id > 0 
      ACCUM t.@flag += true;
    S = SELECT t 
      FROM S-(<HAS_CREATOR)-(Post|Comment)-(REPLY_OF>)-(Post|Comment)-(HAS_CREATOR>)-Person:t
      WHERE NOT t.@visited AND t.@flag AND t.id > 0
      ACCUM t.@visited += true
      LIMIT 100;
  END;
  S = SELECT s FROM S:s ACCUM person2Id = s.id LIMIT 1;
  PRINT person1Id, person2Id;
}

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi16() {
  TYPEDEF TUPLE <INT d, INT nc> dn;
  MapAccum<INT, SumAccum<UINT>> @ncomment;
  HeapAccum<dn>(1, nc DESC, d ASC) @dateCount;  
  STRING tagA, tagB;
  DATETIME dateA, dateB;
  M = SELECT m FROM (Post|Comment):m-(HAS_TAG>)-Tag
    LIMIT 5000;
  T = SELECT t FROM M:m-(HAS_TAG>)-Tag:t
    ACCUM 
      INT d = datetime_diff(m.creationDate, to_datetime("2010-01-01 00:00:00")) / 86400,
      t.@ncomment += (d -> 1)
    POST-ACCUM FOREACH (d, num) IN t.@ncomment DO 
      t.@dateCount += dn(d,num)
      END
    ORDER BY t.@dateCount.top().nc DESC
    LIMIT 2;
  T1 = SELECT t FROM T:t 
    ORDER BY t.@dateCount.top().nc DESC, t.id ASC
    LIMIT 1;
  T = T MINUS T1;
  T2 = SELECT t FROM T:t 
    ORDER BY t.@dateCount.top().nc DESC, t.id ASC
    LIMIT 1;
  T1 = SELECT t FROM T1:t ACCUM tagA=t.name, 
    dateA = datetime_add(to_datetime("2010-01-01 00:00:00"), INTERVAL t.@dateCount.top().d DAY);
  T2 = SELECT t FROM T2:t ACCUM tagB=t.name,
    dateB = datetime_add(to_datetime("2010-01-01 00:00:00"), INTERVAL t.@dateCount.top().d DAY);
  PRINT tagA, dateA, tagB, dateB;
}

# BI18: for large graph, random person1Id usually gives empty results
CREATE OR REPLACE DISTRIBUTED QUERY gen_bi18() {
  UINT person1Id;
  STRING tag;
  OrAccum @visited;
  S = SELECT s FROM Person:s WHERE s.id > 0 LIMIT 1;
  S = SELECT s FROM S:s ACCUM person1Id = s.id;
  P1 = SELECT t FROM S-(KNOWS)-Person:t 
    WHERE t.id > 0 ACCUM t.@visited += TRUE;
  P2 = SELECT t FROM P1-(KNOWS)-Person:t 
    WHERE NOT t.@visited AND t.id > 0 and t.id != person1Id
    LIMIT 1000;
  T = SELECT t FROM P2-(HAS_INTEREST>)-Tag:t LIMIT 1;
  T = SELECT t FROM T:t ACCUM tag = t.name;  
  PRINT person1Id, tag;
}

CREATE OR REPLACE DISTRIBUTED QUERY gen_bi19() {
  SetAccum<UINT> @@cityIds;
  SumAccum<UINT> @nperson;
  C = SELECT c 
    FROM City:c ACCUM c.@nperson += c.outdegree("IS_LOCATED_IN_REVERSE")
    ORDER BY c.@nperson ASC
    LIMIT 3;
  C = SELECT c FROM C:c ACCUM @@cityIds += c.id;
  PRINT @@cityIds;
}


CREATE OR REPLACE DISTRIBUTED QUERY gen_bi20() {
  SetAccum<VERTEX<Person>> @@person2Ids;
  SumAccum<UINT> @nperson;
  //OrAccum<BOOL> @selected;
  UINT iter;
  STRING company;

  U = {University.*};
  U = SELECT u 
    FROM U:u ACCUM u.@nperson += u.outdegree("STUDY_AT_REVERSE")
    ORDER BY u.@nperson ASC
    LIMIT 3;
  
  P = SELECT p
    FROM U -(<STUDY_AT)- Person:p
    WHERE p.id > 0
    LIMIT 10;
  P = SELECT p FROM P:p ACCUM @@person2Ids += p; //p.@selected += TRUE;
  P = SELECT p FROM P:p -(WORK_AT>)-Company:c ACCUM company=c.name;
  PRINT company, @@person2Ids;
}

//INSTALL QUERY gen, gen_bi10, gen_bi15, gen_bi16, gen_bi18, gen_bi19, gen_bi20
//RUN QUERY gen_bi19()
//INTERPRET QUERY gen()

